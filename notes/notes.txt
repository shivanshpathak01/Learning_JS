->JS is single threaded and every thing is a Process in JS 
->Printing - Many variables at a time console.log([variable1,variable2,variable3]);
->Object type  of null is object;
->we use `${}` for Printing
->In array functions, {arr.slice()  =>> Array doesn't get modified} , While in {arr.splice =>> Array get modified}
-> Array concatanation =>> 1. [...arr1,...arr2] Normal concatanation of two arrays   2.If we have to cancatanate the array inside the array inside array we use arr.flat(number of inside arrays) method         
->Objects =>> 1. Keys are considered as strings, 2.Symbols are declared as {[mySymbol]:"hi"} 3. Instead of using .(dot) operator in some situations we can use console.log(user[variable1]) also  3. We can make the object unchangeable by Object.freeze(object name);
->Objects inside objects can be accessed by using (.) dot operator 
->To merge the objects like Arrays, we use Objects.assign(), ({},obj1,obj2...) We use {} so that the objects get merged easily and looks more professional but not necessarily imp
->But the easiest way to merge the object is just like the arrays {...obj1,...obj2} 
->By object.keys(), we can  convert the object into the arrays And also use Object.values() to get their respective values 
->Destructuring of an Object in JS means changing its POV of calling means JavaScript.user will become user or myuser whatever easy name you want to give instead of typing JavaScript. every time 
->For above concept, fun({destructured object}), curly braces are used 
-> JSON(JavaScript object notation) is for APIs(APIs handle the task of others)
-> Functions : function hello(){}, this is how the functions are being written 
-> hello, this is the referance, while hello(), this is the execution of the function.
-> In any function, if argument remains empty, automatically return undefined not null.
->If in any function we have given one argument but i have to return more number of values then we use (...variableName) in function itself while passing the argument 
-> The above mentioned (...) is called REST operator {Previously used as spread operator for merging the arrays}.
-> If in above argument we pass (var1,var2,...num1), and pass 10 values in function then first two values will be assigned to the given two varibales(i.e. var1 and var2) and all the others will be then assigned by REST operator as mentioned above.
-> If any function being stored in any variable, it will be sometimes called Expression and if we call the variablein which it is stored above where it is written it will give me error because it was stored in a variable .
-> this Keyword is used to refer to current context means for ex. in this codeblock only, means when you will change the value of the variable, it will change
-> In Browser everything is stored under window object, So value for this in browser comes out to be under Window while in VS(node) it came out as {} - empty
-> In Arrow Function, If we wrap the values in {} we have to write return keyword, Else we don't need to write the return keyword
-> Brackets are usually used in these cases and they are mostly used in React 
-> IIFE(Immediately Invoked function Expression) used to remove the pollution caused by global scope variable And IIFE is invoked Immediately.
-> We wrap the function and next line which we want to execute like this ()().
-> Always use ; Semicolon in IIFE that tells it where to stop

/////***    How JS Programmes works    ***/////

-> 1.JS Execution Context => Firstly It is Global EC (this keyword is assigned there)=>{code}
-> 2.Function or Functional EC
-> 3.Eval EC  
-> Code is Executed like {}=>1.Memory Creation Phase or Creation Phase => Memory assigned in this Phase
-> 2. Execution Phase => Execution in this Phase
-> Let's Say there is a program where we have to add two numbers So the Execution is like :

//***       Phase 1st       ****///
Global execution Phase => Here this is assigned or given 

//***       Phase 2nd       ****///
Memory Phase 
Step1. undefined is assigned to both the variables (num1 = undefined,num2 = undefined)
Step2. defination of function is given to function's name
Step3. result is undefined yet and is stored in some variable (Let's call it result)

//***       Phase 3rd       ****///
Execution Phase 
Step1. values are assigned to both variables (num1 = 10,num2 = 2);
Step2. It goes to function and there a new variable environment + Execution thread is created
Step3. Result will be again returned to Global EC

-> In call stack of programmes here, LIFO is used (Firstly,Global EC,then fun1(),Fun2()...),means Fun2() will be taken out first after execution. (Refer to Video 25)
-> '===' Checks both the values as well as the datatype of values whether they are same or not.
-> In switch case,if the break statement is removed and if the value matches then every other statements below it gets executed except default case that's why break statement is there.
-> if we have check the strings in switch statement then we can write them at the place where we write case 1 as case "string";
-> if you do not have to give some condition in if-else statement just you have to place the variable there, and your code works for that we use truthy or falsy values there.
-> all the falsy values are listed below else others are truthy : 
    false, 0, -0, BigInt 0n, "", null, undefined, Nan
-> All the surprising truthy values : "0", 'false', " ", [],{},function(){}.
-> If we have to check whether the array is empty or not then check by (.length) operator, for ex. (arr1.length===0) log 
-> To check an empty Object, apply the same method as arrays mentioned above (Refer truthy.js)
 
